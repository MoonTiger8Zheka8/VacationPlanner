@page "/planner"
@rendermode InteractiveServer
@inject VacationPlanner.Application.Interfaces.IVacationPlannerService PlannerService
@inject IJSRuntime JS
@implements IDisposable

@using VacationPlanner.Domain.Enums
@using VacationPlanner.Domain.Models
@using VacationPlanner.Components.Shared
<h3>–ü–ª–∞–Ω—É–≤–∞–Ω–Ω—è –≤—ñ–¥–ø—É—Å—Ç–∫–∏</h3>

<div class="card p-3 mb-3">
    
    <div class="mb-3">
    <label class="form-label">–ú—ñ—Å—Ü–µ</label>

    <div class="input-group">
        <input class="form-control" @bind="request.Destination" />
        <button class="btn btn-outline-secondary" type="button" title="–ì–æ–ª–æ—Å–æ–≤–∏–π –≤–≤—ñ–¥"
                @onclick="@(() => StartVoiceFor("destination"))">
            üé§
        </button>
    </div>
</div>

<div class="mb-3">
    <label class="form-label">–ö—ñ–ª—å–∫—ñ—Å—Ç—å –¥–Ω—ñ–≤</label>

    <div class="input-group">
        <input type="number" class="form-control" @bind="request.Days" />
        <button class="btn btn-outline-secondary" type="button" title="–ì–æ–ª–æ—Å–æ–≤–∏–π –≤–≤—ñ–¥"
                @onclick="@(() => StartVoiceFor("days"))">
            üé§
        </button>
    </div>
</div>

<div class="mb-3">
    <label class="form-label">–¢–∏–ø –ø–æ—ó–∑–¥–∫–∏</label>

    <div class="input-group">
        <select class="form-select" @bind="request.Type">
            <option value="Excursions">–ï–∫—Å–∫—É—Ä—Å—ñ—ó, —Ü—ñ–∫–∞–≤—ñ –º—ñ—Å—Ü—è</option>
            <option value="Active">–ê–∫—Ç–∏–≤–Ω–∏–π –≤—ñ–¥–ø–æ—á–∏–Ω–æ–∫</option>
            <option value="Relax">–†–µ–ª–∞–∫—Å, —Å–ø–æ–∫—ñ–π–Ω–∏–π –≤—ñ–¥–ø–æ—á–∏–Ω–æ–∫</option>
        </select>

        <button class="btn btn-outline-secondary" type="button" title="–ì–æ–ª–æ—Å–æ–≤–∏–π –≤–≤—ñ–¥"
                @onclick="@(() => StartVoiceFor("type"))">
            üé§
        </button>
    </div>
</div>
    <button class="btn btn-primary mt-2" @onclick="Generate">
        –ó–ì–ï–ù–ï–†–£–í–ê–¢–ò –ü–õ–ê–ù
    </button>
</div>

@if (plan is not null)
{
    <h4>–†–µ–∑—É–ª—å—Ç–∞—Ç</h4>

    //<p><b>–û—Ü—ñ–Ω–æ—á–Ω–∞ –≤–∞—Ä—Ç—ñ—Å—Ç—å:</b> @plan.TotalEstimatedCost –≥—Ä–Ω</p>

    @foreach (var day in plan.Days)
    {
        <div class="card p-3 mb-2">
            <h5>@day.Title</h5>
            

            <div class="row g-3">
            @foreach (var place in day.Places)
            {
                <div class="col-md-6 col-lg-4">
                    <PlaceCard Place="place"
                        IsSelected="@(selectedPlaceId == place.Id)"
                        OnShowOnMap="ShowPlaceOnMap" />
                </div>
            }
</div>
        </div>
    }
}
@if (plan is not null)
{
    <div class="card p-3 mb-3">
        <h5>–ö–∞—Ä—Ç–∞ –º–∞—Ä—à—Ä—É—Ç—É</h5>
        <div id="map" style="height: 400px;"></div>
    </div>
}

@code {
    private bool mapRendered = false;
    private VacationRequest request = new()
    {
        Destination = "–õ—å–≤—ñ–≤",
        Days = 3,
        Budget = 10000,
        People = 1,
        Type = VacationType.Excursions
    };

    private VacationPlan? plan;

    private async Task Generate()
    {
        mapRendered = false;
        plan = await PlannerService.GeneratePlanAsync(request);
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (plan is not null && !mapRendered)
            await RenderMap();
    }

    private async Task RenderMap()
    {
        // –∑–∞—Ö–∏—Å—Ç –≤—ñ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–∏—Ö —Ä–µ–Ω–¥–µ—Ä—ñ–≤
        if (mapRendered) return;
        mapRendered = true;

        if (plan?.Days == null || plan.Days.Count == 0)
            return;

        // –ø–µ—Ä—à–∞ —Ç–æ—á–∫–∞ –∑ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
        var first = plan.Days
            .OrderBy(d => d.DayNumber)
            .SelectMany(d => d.Places)
            .FirstOrDefault(p => p.Lat.HasValue && p.Lon.HasValue);

        if (first is null)
            return;

        // init –∫–∞—Ä—Ç–∞
        await JS.InvokeVoidAsync("leafletMap.init", "map", first.Lat!.Value, first.Lon!.Value, 12);

        // —Ç–æ—á–∫–∏ –≤ –ø–æ—Ä—è–¥–∫—É
        var orderedPlaces = plan.Days
            .OrderBy(d => d.DayNumber)
            .SelectMany(d => d.Places)
            .Where(p => p.Lat.HasValue && p.Lon.HasValue)
            .ToList();

        
        if (orderedPlaces.Count == 0)
            return;

        //  markers
        int order = 1;
        foreach (var place in orderedPlaces)
        {
            await JS.InvokeVoidAsync(
                "leafletMap.addNumberedMarker",
                place.Id,                 
                order,                    
                place.Lat!.Value,
                place.Lon!.Value,
                place.Name
            );

            order++;
        }

        
        await JS.InvokeVoidAsync("leafletMap.drawRoute");

        
        await JS.InvokeVoidAsync("leafletMap.fitBounds");
    }
    private string? selectedPlaceId;
    private async Task ShowPlaceOnMap(PlaceInfo place)
    {
        selectedPlaceId = place.Id;
        await JS.InvokeVoidAsync("leafletMap.selectPlace", place.Id);
    }
    private DotNetObjectReference<Planner>? objRef;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            objRef = DotNetObjectReference.Create(this);
        }
    }

    private async Task StartVoiceFor(string targetField)
    {
        objRef ??= DotNetObjectReference.Create(this);

        await JS.InvokeVoidAsync("voiceAssistant.startRecognition", objRef, targetField);
    }

    [JSInvokable]
    public void OnSpeechRecognized(string text, string targetField)
    {
        text = text.Trim();

        switch (targetField)
        {
            case "destination":
                request.Destination = ToTitle(text);
                break;

            case "days":
                if (TryParseUkrainianNumber(text, out var days))
                    request.Days = days;
                break;

            case "type":
                if (TryParseVacationType(text, out var type))
                    request.Type = type;
                break;
        }

        StateHasChanged();
    }

    [JSInvokable]
    public void OnSpeechError(string error, string targetField)
    {
        Console.WriteLine($"Voice error ({targetField}): {error}");
    }

    private static string ToTitle(string text)
    {
        if (string.IsNullOrWhiteSpace(text)) return "";
        return char.ToUpper(text[0]) + text.Substring(1);
    }

    private static bool TryParseVacationType(string text, out VacationPlanner.Domain.Enums.VacationType type)
    {
        var t = text.ToLowerInvariant();

        if (t.Contains("–µ–∫—Å–∫—É—Ä—Å")) { type = VacationPlanner.Domain.Enums.VacationType.Excursions; return true; }
        if (t.Contains("–∞–∫—Ç–∏–≤")) { type = VacationPlanner.Domain.Enums.VacationType.Active; return true; }
        if (t.Contains("—Ä–µ–ª–∞–∫—Å") || t.Contains("–≤—ñ–¥–ø–æ—á") || t.Contains("—Å–ø–æ–∫—ñ–π")) { type = VacationPlanner.Domain.Enums.VacationType.Relax; return true; }
        if (t.Contains("–ø–ª—è–∂") || t.Contains("–º–æ—Ä–µ")) { type = VacationPlanner.Domain.Enums.VacationType.Beach; return true; }

        // fallback
        type = VacationPlanner.Domain.Enums.VacationType.Relax;
        return false;
    }

    private static bool TryParseUkrainianNumber(string text, out int number)
    {
        var t = text.Trim().ToLowerInvariant();

        
        if (int.TryParse(new string(t.Where(char.IsDigit).ToArray()), out number))
            return number > 0;

        // —Å–ª–æ–≤–∞
        var map = new Dictionary<string, int>
        {
            ["–æ–¥–∏–Ω"] = 1, ["–æ–¥–Ω–∞"] = 1, ["–ø–µ—Ä—à–∏–π"] = 1,
            ["–¥–≤–∞"] = 2, ["–¥–≤—ñ"] = 2, ["–¥—Ä—É–≥–∏–π"] = 2,
            ["—Ç—Ä–∏"] = 3, ["—Ç—Ä–µ—Ç—ñ–π"] = 3,
            ["—á–æ—Ç–∏—Ä–∏"] = 4,
            ["–ø'—è—Ç—å"] = 5, ["–ø—è—Ç—å"] = 5,
            ["—à—ñ—Å—Ç—å"] = 6,
            ["—Å—ñ–º"] = 7,
            ["–≤—ñ—Å—ñ–º"] = 8,
            ["–¥–µ–≤'—è—Ç—å"] = 9, ["–¥–µ–≤—è—Ç—å"] = 9,
            ["–¥–µ—Å—è—Ç—å"] = 10
        };

        foreach (var kv in map)
        {
            if (t.Contains(kv.Key))
            {
                number = kv.Value;
                return true;
            }
        }

        number = 0;
        return false;
    }

    public void Dispose()
    {
        objRef?.Dispose();
    }   
}
